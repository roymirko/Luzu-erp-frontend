import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { AuditLog, LogAction, LogEntity, LogResult } from '../types/business';
import { supabase } from '../services/supabase';
import { mapLogFromDB, mapLogToDB } from '../utils/supabaseMappers';

interface LogContextType {
  logs: AuditLog[];
  addLog: (log: Omit<AuditLog, 'id' | 'timestamp'>) => void;
  clearLogs: () => void;
  getLogsByUser: (userId: string) => AuditLog[];
  getLogsByEntity: (entity: LogEntity) => AuditLog[];
  getLogsByAction: (action: LogAction) => AuditLog[];
  getLogsByDateRange: (startDate: Date, endDate: Date) => AuditLog[];
  getRecentLogs: (hours?: number) => AuditLog[];
  searchLogs: (query: string) => AuditLog[];
  getLogStats: () => {
    totalLogs: number;
    successCount: number;
    errorCount: number;
    warningCount: number;
    recentLogsCount: number;
    logsByAction: Record<LogAction, number>;
    logsByEntity: Record<string, number>;
  };
}

const LogContext = createContext<LogContextType | undefined>(undefined);

export function LogProvider({ children }: { children: ReactNode }) {
  const [logs, setLogs] = useState<AuditLog[]>([]);

  // Fetch initial logs
  useEffect(() => {
    const fetchLogs = async () => {
      try {
        const { data, error } = await supabase
          .from('registros_auditoria')
          .select('*')
          .order('fecha', { ascending: false })
          .limit(500); // Limit to recent 500 logs for performance

        if (error) {
          console.error('Error fetching logs:', error);
          return;
        }

        if (data) {
          setLogs(data.map(mapLogFromDB));
        }
      } catch (error) {
        console.error('Error fetching logs:', error);
      }
    };

    fetchLogs();
  }, []);

  // Agregar nuevo log
  const addLog = async (logData: Omit<AuditLog, 'id' | 'timestamp'>) => {
    const newLogBase = {
      ...logData,
      // Suppress timestamp here, let DB handle it or we set it?
      // DB defaults to now(), but mapper expects it.
      // Better to let DB set it, then fetch it back or use returned value.
    };

    // We can't rely on 'id' being generated by DB if we want to update local state immediately accurately with ID.
    // However, for logs, we just append.

    // Convert to DB format
    // mapLogToDB expects partial AuditLog.
    const dbLog = mapLogToDB(logData);

    const { data: insertedLog, error } = await supabase
      .from('registros_auditoria')
      .insert(dbLog)
      .select()
      .single();

    if (error || !insertedLog) {
      console.error('Error adding log:', error);
      return;
    }

    const newLog = mapLogFromDB(insertedLog);

    setLogs(prev => [newLog, ...prev]);
  };

  // Limpiar todos los logs
  const clearLogs = async () => {
    if (window.confirm('¿Estás seguro de que deseas eliminar todos los logs? Esta acción no se puede deshacer.')) {
      const { error } = await supabase
        .from('registros_auditoria')
        .delete()
        .neq('id', '00000000-0000-0000-0000-000000000000');
      // Or better: .gt('fecha', '1970-01-01')

      if (!error) {
        setLogs([]);
      }
    }
  };

  // Filtrar logs por usuario
  const getLogsByUser = (userId: string): AuditLog[] => {
    return logs.filter(log => log.userId === userId);
  };

  // Filtrar logs por entidad
  const getLogsByEntity = (entity: LogEntity): AuditLog[] => {
    return logs.filter(log => log.entity === entity);
  };

  // Filtrar logs por acción
  const getLogsByAction = (action: LogAction): AuditLog[] => {
    return logs.filter(log => log.action === action);
  };

  // Filtrar logs por rango de fechas
  const getLogsByDateRange = (startDate: Date, endDate: Date): AuditLog[] => {
    return logs.filter(log => {
      // log.timestamp is already Date object from mapper
      return log.timestamp >= startDate && log.timestamp <= endDate;
    });
  };

  // Obtener logs recientes (por defecto últimas 24 horas)
  const getRecentLogs = (hours: number = 24): AuditLog[] => {
    const now = new Date();
    const cutoffTime = new Date(now.getTime() - hours * 60 * 60 * 1000);
    return logs.filter(log => log.timestamp >= cutoffTime);
  };

  // Buscar logs por texto
  const searchLogs = (query: string): AuditLog[] => {
    const lowerQuery = query.toLowerCase();
    return logs.filter(log =>
      log.userEmail.toLowerCase().includes(lowerQuery) ||
      log.entityName.toLowerCase().includes(lowerQuery) ||
      log.details.toLowerCase().includes(lowerQuery) ||
      log.action.toLowerCase().includes(lowerQuery)
    );
  };

  // Obtener estadísticas de logs
  const getLogStats = () => {
    const totalLogs = logs.length;
    const successCount = logs.filter(l => l.result === 'exito').length;
    const errorCount = logs.filter(l => l.result === 'error').length;
    const warningCount = logs.filter(l => l.result === 'advertencia').length;
    const recentLogsCount = getRecentLogs(24).length;

    // Contar por acción
    const logsByAction = logs.reduce((acc, log) => {
      acc[log.action] = (acc[log.action] || 0) + 1;
      return acc;
    }, {} as Record<LogAction, number>);

    // Contar por entidad
    const logsByEntity = logs.reduce((acc, log) => {
      acc[log.entity] = (acc[log.entity] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      totalLogs,
      successCount,
      errorCount,
      warningCount,
      recentLogsCount,
      logsByAction,
      logsByEntity
    };
  };

  return (
    <LogContext.Provider
      value={{
        logs,
        addLog,
        clearLogs,
        getLogsByUser,
        getLogsByEntity,
        getLogsByAction,
        getLogsByDateRange,
        getRecentLogs,
        searchLogs,
        getLogStats
      }}
    >
      {children}
    </LogContext.Provider>
  );
}

export function useLog() {
  const context = useContext(LogContext);
  if (!context) {
    throw new Error('useLog debe usarse dentro de un LogProvider');
  }
  return context;
}
